<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DG-AC</title>
  </head>
  <body>
    <canvas width="400" height="300"></canvas>
    <!--canvas width="400" height="300"></canvas>-->
    <div>
      <select name="method">
        <option value="life">Game of Life</option>
        <option value="death">Game of Death</option>
        <option value="wall">Game of Wall</option>
      </select>
      <select name="scenarios">
        <option value="">Scenarios</option>
        <option value="gliders">Gliders</option>
        <option value="reset1">Reset 1</option>
      </select>
      <button>Step</button>
      <button>Play</button>
      <button>Stop</button>
      
    </div>
    <script type="module">
      const W = 400;
      const H = 300;
      const S = 10;
      const HS = H / S;
      const WS = W / S;
      const COLORS = ["tan", "chocolate", "brown"];
      console.log(S, W, H, WS, HS);
      var steps = 0;
      var map = [];
      var map2 = [];
      var te = 0;
      var dt = 0;
      map = initMap(HS, WS, 1);
      map2 = initMap(HS, WS, 1);
      var animation = true;
      var method = gameOfLifeRulesAutomata;

      var canvas = document.querySelector("canvas");
      var buttons = document.querySelectorAll("button");
      var selectMethod = document.querySelectorAll("select")[0];
      var selectScenario = document.querySelectorAll("select")[1];
      canvas.width = W;
      canvas.height = H;
      var ctx = canvas.getContext("2d");
      drawMap(map);
      var animationID;
      
      selectMethod.addEventListener("change", function(e){
        console.log(e.target.value);
        switch (e.target.value) {
          case "death":
            method = gameOfDeathRulesAutomata;
            break;  
          default:
            e.target.value = "life";
            method = gameOfLifeRulesAutomata;
          break;
        }
        
      });

      selectScenario.addEventListener("change", function(e){
        console.log(e.target.value);
        switch (e.target.value) {
          case "gliders":
            scenarioPutGliders(map);
            e.target.value = "";
            break;  
          case "reset1":
            scenarioReset1();
            e.target.value = "";
          break;  
          default:
          
          break;
        }
      });

      canvas.addEventListener("click", function(e) {
        const tC = Math.floor(e.offsetX / S);
        const tL = Math.floor(e.offsetY / S);

        const d = map[tL][tC]<2?map[tL][tC]+1:0;
        setArea(map, tC, tL, 1, 1, d);
        drawMap(map);
      });

      function setArea(mapx, x, y, w, h, v) {
        const mL = Math.max(y, 0);
        const ML = Math.min(y + h, mapx.length);
        const mC = Math.max(x, 0);
        const MC = Math.min(x + w, mapx[0].length);
        for (let l = mL; l < ML; l++) {
          for (let c = mC; c < MC; c++) {
            mapx[l][c] = v;
          }
        }
      }

      function fullstep(t) {
        dt = (t - te) / 1000;
        method();
        toggleMaps();
        drawMap(map);
        te = t;
        steps--;
        if (steps > 0) {
          requestAnimationFrame(fullstep);
        }
      }

      function fullstepWithoutSteps(t){
        dt = (t - te) / 1000;
        method();
        toggleMaps();
        drawMap(map);
        te = t;
        if (animation) {
          requestAnimationFrame(fullstepWithoutSteps);
        }        
      }

      function drawMap(mapx) {
        for (let l = 0; l < mapx.length; l++) {
          for (let c = 0; c < mapx[0].length; c++) {
            ctx.fillStyle = COLORS[mapx[l][c]];
            ctx.fillRect(c * S, l * S, S, S);
            if(mapx[l][c] === 2){
              ctx.strokeStyle = "black";
              ctx.strokeRect(c * S, l * S, S, S);
            }
          }
        }
      }

      function countAdjacents(mapx, y, x, tp) { //Conta as células de um tipo específico ao redor da célula (x,y)
        let total = 0;
        const mL = Math.max(y - 1, 0);
        const ML = Math.min(y + 1, mapx.length-1);
        const mC = Math.max(x - 1, 0);
        const MC = Math.min(x + 1, mapx[0].length-1);
        for (let l = mL; l <= ML; l++) {
          for (let c = mC; c <= MC; c++) {
            if (mapx[l][c] === tp) {
              total++;
            }
          }
        }
        if(mapx[y][x] === tp){ //Desconta o valor da celula central
          total--;
        }
        return total;
      }

      function toggleMaps() {
        map = JSON.parse(JSON.stringify(map2)); //Copia matriz
      }

      function initMap(L, C, v) {
        let mapx = [];
        for (let l = 0; l < L; l++) {
          mapx[l] = [];
          for (let c = 0; c < C; c++) {
            mapx[l][c] = v;
          }
        }
        return mapx;
      }

      function gameOfLifeRulesAutomata(){
        for (let l = 0; l < map2.length; l++) {
          for (let c = 0; c < map2[0].length; c++) {
            map2[l][c] = map[l][c];
            switch (map[l][c]) {
              case 1: //Celula morta
                if(countAdjacents(map, l, c, 2) === 3){ //Com 3 vizinhos vivos, renasce
                  map2[l][c] = 2;
                }
                break;
              case 2: //Celula viva
                if (countAdjacents(map, l, c, 2) >= 2 && countAdjacents(map, l, c, 2) <= 3) {
                  map2[l][c] = 2;
                }
                else if (countAdjacents(map, l, c, 2) >= 0 && countAdjacents(map, l, c, 2) <= 1) {
                  map2[l][c] = 1;
                }
                else if (countAdjacents(map, l, c, 2) >= 4){
                  map2[l][c] = 1;
                }
                break;
            }
          }
        }
      }

      function gameOfDeathRulesAutomata(){
        for (let l = 0; l < map2.length; l++) {
          for (let c = 0; c < map2[0].length; c++) {
            map2[l][c] = map[l][c];
            switch (map[l][c]) {
              case 1: //Celula morta
                if(countAdjacents(map, l, c, 2) === 2){ //Com 3 vizinhos vivos, renasce
                  map2[l][c] = 1;
                }
                break;
              case 2: //Celula viva
                if (countAdjacents(map, l, c, 2) >= 2 && countAdjacents(map, l, c, 2) <= 1) {
                  map2[l][c] = 2;
                }
                else if (countAdjacents(map, l, c, 2) >= 0 && countAdjacents(map, l, c, 2) <= 1) {
                  map2[l][c] = 1;
                }
                else if (countAdjacents(map, l, c, 2) >= 4){
                  map2[l][c] = 1;
                }
                break;
            }
          }
        }
      }

      function scenarioPutGliders(map){
        // 1 Glider
        map[27][37] = 2;
        map[27][38] = 2;
        map[26][38] = 2;
        map[28][37] = 2;
        map[28][39] = 2;

        // 2 Glider
        map[10][10] = 2;
        map[10][11] = 2;
        map[9][11] = 2;
        map[11][10] = 2;
        map[11][12] = 2;

        //map[29][39] = 0;// Ponto final do mapa
        drawMap(map);
      }

    function scenarioReset1() {
      animation = false;
            map  = initMap(HS, WS, 1);
            map2 = initMap(HS, WS, 1);
            animation = true;
            drawMap(map);
    }

      buttons[0].addEventListener("click", function(){
        steps = 1;
        fullstep();
      });

      buttons[1].addEventListener("click", function(){
        animation = true;
        fullstepWithoutSteps();
      });

      buttons[2].addEventListener("click", function(){
        animation = false;
        steps = 0;
      });


    </script>
  </body>
</html>